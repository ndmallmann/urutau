"""
    Examples of how to run Urutau with a few modules.
"""

# Importing the urutau class
from urutau import Urutau

# Importing all the relevant modules
from urutau.modules import (
    ButterworthFilter,
    CcmLaw,
    SNMaskWithIVar,
    StarlightOnUrutau
)


def example():

    # Open urutau (with two threads to process data)
    urutau = Urutau(num_threads=2)

    # Add each module in SEQUENCE of execution

    # ButterworthFilter
    # If no configuration is give, it will use only default values.
    #
    # In this case, the default values for ButterworthFilter are:
    #
    #   "hdu flux" = hdu name with flux data (default = "FLUX")
    #   "order" = butterworth order (default = 3)
    #   "range" = butterworth range (default = 0.3)
    urutau.add_module(ButterworthFilter)

    # CcmLaw
    # Default "hdu flux" is "FLUX", but we want to run this module on the
    # hdu produced by the ButterworthFilter ("FLUX_BW")
    #
    # Since no other parameter is configured besides "hdu flux", their values
    # will be the default one.
    ccm_cfg = {"hdu flux": "FLUX_BW"}
    urutau.add_module(CcmLaw, ccm_cfg)

    # SNMaskWithIVar MODULE
    # Similar to the configuration of CcmLaw, we want to run the singal to
    # noise mask on the resulting hdu (from CcmLaw, i.e., "FLUX_DRD")
    #
    # This module utilizes the inverce variance data from the HDU "IVAR" to
    # calculate the SN mask.
    #
    # Signal to noise window and thresholds are changed from the default values
    # (default "sn window" = [4000, 6000] and default "thresholds" = [10])
    sn_mask_cfg = {
        "hdu flux": "FLUX_DRD",
        "hdu ivar": "IVAR",
        "sn window": (5650, 5750),
        "thresholds": [1, 5, 10, 20]
    }
    urutau.add_module(SNMaskWithIVar, sn_mask_cfg)

    # StarlightOnUrutau MODULE
    #
    # Creating a dictionary with the desired population vectors and their
    # age limits (min, max) to be used with the starlight configuration
    pop_age_par = {
        "xyy": [0, 10.1E6],
        "xyo": [10.1E6, 56.3E6],
        "xiy": [56.3E6, 502.0E6],
        "xii": [502.0E6, 795.0E6],
        "xio": [795.0E6, 2.01E9],
        "xo": [2.01E9, 13E9]
    }

    # Using the flux hdu generated by CcmLaw ("FLUX_DRD") and the mask hdu
    # generated by the SignalToNoiseMask ("FN_MASKS_10") as the flag
    # for bad spaxels
    #
    # Setting up the path to the starlight static executable and a reference
    # grid (see Cid Fernandes' starlight manual) as well as the population ages
    #
    # Obs: the reference grid must contain at least 1 mock target line (see
    #      example "reference_grid.in")
    starlight_cfg = {
        "hdu flux": "FLUX_DRD",
        "hdu flag": "SN_MASKS_10",
        "starlight path": "../starlight/StarlightChains_v04.amd64_gfortran-4.1.1_static.exe",
        "default grid file": "./reference_grid.in",
        "population ages": pop_age_par,
    }
    urutau.add_module(StarlightOnUrutau, starlight_cfg)

    # Load targets
    # You can load the targets with two methods
    # Using adding target by target or using a csv file
    #
    # The csv file has the advantage of considering every column as a potential
    # parameter to be used by the modules. As an example, see the file
    # "targets.csv". Every module containing a "redshift" parameter will use
    # CSV file column labeled "redshift" as an input (effectively giving a
    # different value of redshift for each target).
    urutau.read_csv(targets_dir="./datacubes/", csv_file="./targets.csv")

    # The other method (target by target)
    #
    # For example:
    #
    #     target_parameters = {
    #           "redshift": 0.04702,
    #           "galaxy distance": 202.66,
    #           "ebv": 0.036
    #     }
    #     urutau.add_target("./datacubes/Mrk926.fits", target_parameters)

    # Execute urutau
    # If save_config is true, urutau will append a configuration hdu to every
    # resulting datacube with the relevant configuration parameters
    urutau.execute("./urutau_results/", save_config=True)
