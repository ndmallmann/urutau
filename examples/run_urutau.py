"""
    Examples of how to run Urutau with a few modules.
"""

# Importing the urutau class
from urutau import Urutau

# Importing all the relevant modules
from urutau.modules import (
    ButterworthFilter,
    CcmLaw,
    SignalToNoiseMask,
    StarlightOnUrutau
)

def example():

    # Open urutau
    urutau = Urutau()

    # Number of threads (number of datacubes to be processed simultaneously)
    urutau.set_number_of_threads(2)

    # Add desired modules to the pipeline (in order)
    modules = [ButterworthFilter, CcmLaw,
               SignalToNoiseMask, StarlightOnUrutau]
    urutau.set_modules(modules)

    # Configure each module
    # You only need to configure a module to change default values

    # CcmLaw
    # Default "hdu flux" is "FLUX", but we want to run this module on the
    # hdu produced by the ButterworthFilter ("FLUX_BW")
    ccm_cfg = {"hdu flux": "FLUX_BW"}
    urutau.config_module(CcmLaw, ccm_cfg)

    # SignalToNoiseMask
    # Similar to the configuration of CcmLaw, we want to run the singal to
    # noise mask on the resulting hdu (from CcmLaw, i.e., "FLUX_DRD")
    #
    # For the signal to noise mask, either "hdu ivar", "hdu error" or "hdu var"
    # must be given
    #
    # Signal to noise window and thresholds are changed from the default values
    # (default "sn window" = [4000, 6000] and default "thresholds" = [10])
    sn_mask_cfg = {
        "hdu flux": "FLUX_DRD",
        "hdu ivar": "IVAR",
        "sn window": (5650, 5750),
        "thresholds": [1, 5, 10, 20]
    }
    urutau.config_module(SignalToNoiseMask, sn_mask_cfg)

    # StarlightOnUrutau
    #
    # Creating a dictionary with the desired population vectors and their
    # age limits (min, max) to be used with the starlight configuration
    pop_age_par = {
        "xyy": [0, 10.1E6],
        "xyo": [10.1E6, 56.3E6],
        "xiy": [56.3E6, 502.0E6],
        "xii": [502.0E6, 795.0E6],
        "xio": [795.0E6, 2.01E9],
        "xo": [2.01E9, 13E9]
    }

    # Using the flux hdu generated by CcmLaw ("FLUX_DRD") and the mask hdu
    # generated by the SignalToNoiseMask ("FN_MASKS_10") as the flag
    # for bad spaxels
    #
    # Setting up the path to the starlight static executable and a reference
    # grid (see Cid Fernandes' starlight manual) as well as the population ages
    # 
    # Obs: the reference grid must contain at least 1 mock target line (see 
    #      example "reference_grid.in") 
    starlight_cfg = {
        "hdu flux": "FLUX_DRD",
        "hdu flag": "SN_MASKS_10",
        "starlight path": "../starlight/StarlightChains_v04.amd64_gfortran-4.1.1_static.exe",
        "default grid file": "./reference_grid.in",
        "population ages": pop_age_par,
    }
    urutau.config_module(StarlightOnUrutau, starlight_cfg)

    # Load targets
    # You can load the targets with two methods
    # Using a list of paths or a csv file
    # 
    # The csv file has the advantage of considering every column as a potential
    # parameter to be used by the modules. As an example, see the file
    # "targets.csv". Every module containing a "redshift" parameter will use
    # CSV file column labeled "redshift" as an input (effectively giving a
    # different value of redshift for each target).
    urutau.read_csv(targets_dir="./datacubes/", csv_file="./targets.csv")

    # Using a list of path requires you to adjust every specific parameter
    #
    # For example:
    #
    #     target_parameters = {
    #         "./datacubes/Mrk926.fits":
    #         {
    #           "redshift": 0.04702,
    #           "galaxy distance": 202.66,
    #           "ebv": 0.036 
    #         }
    #     }
    #
    #     targets_list = [t for t in target_parameters.keys()]
    #
    #     urutau.load_targets(targets_list)
    #     urutau.load_target_specific_parameters(target_parameters)

    # Execute urutau
    # If save_config is true, urutau will append a configuration hdu to every
    # resulting datacube with the relevant configuration parameters
    urutau.execute("./urutau_results/", save_config=True)